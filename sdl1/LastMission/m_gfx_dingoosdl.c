/*

	SDL video backend for handheld consoles
	Screen resolutions:
		320x240x16 for Dingoo A320 (Native OS, Dingux, OpenDingux), GP32, Wiz or Caanoo UNTESTED
		400x240x16 for Dingoo A380 (uses Dingux variant) UNTESTED
		480x272x16 for Ritmix RZX-50 (R480) (uses Dingux variant)
	For the last one, the A320 compatibility mode is shitty, do screen centering ourselves

*/

#include "m_core.h"
#include "m_gfx.h"
#include "SDL.h"

// forward def of palette in RGBA format
extern unsigned char pal256[1024];

unsigned char Keys[128] = { 0 };

int LM_GFX_Init();
void LM_GFX_Deinit();

SDL_Surface *small_screen = NULL;
SDL_Surface *screen = NULL;

#if defined(__DINGUX__)
int VMode = 0; // 0 - 320x240, 1 - 400x240, 2 - 480x272
int StretchFullScreen = 0; // 0 - no stretch, 1 - bilinear stretch
#define NUMOFVIDEOMODES 3
struct {
	int x;
	int y;
} VModes[NUMOFVIDEOMODES] = {
	{320, 240},
	{400, 240},
	{480, 272}
};
#endif

//===============================================================
void LM_ResetKeys()
{
	memset(&Keys[0], 0, 128);
}

int LM_AnyKey()
{
	for (int i = 0; i < 127; i++)
	{
		if (Keys[i] == 1) return 1;
	}
	return 0;
}

int LM_Timer()
{
	return SDL_GetTicks();
}

void LM_Sleep(int sleep_time)
{
	SDL_Delay(sleep_time);
}

int LM_Init(unsigned char **pScreenBuffer)
{
	if (LM_GFX_Init() == 0) return 0;

	*pScreenBuffer = (unsigned char *)small_screen->pixels;
	return 1;
}

void LM_Deinit()
{
	LM_GFX_Deinit();
}

char LM_PollEvents()
{
	SDL_Event event;

	while (SDL_PollEvent(&event) != 0)
	{
		int key_scan = -1;
		unsigned char key_value = 0;

		if (event.type == SDL_QUIT) { Keys[SC_ESCAPE] = 1; return 1; }

		// dingoo sdl doesn't have scancode, so remap usual keys
		if (event.type == SDL_KEYDOWN) key_value = 1;
		if (event.type == SDL_KEYUP) key_value = 0;

		// Emulate x86 scancodes
		if (event.type == SDL_KEYDOWN || event.type == SDL_KEYUP)
		{
			switch (event.key.keysym.sym)
			{
			case SDLK_UP:
				key_scan = SC_UP;
				break;
			case SDLK_DOWN:
				key_scan = SC_DOWN;
				break;
			case SDLK_LEFT:
				key_scan = SC_LEFT;
				break;
			case SDLK_RIGHT:
				key_scan = SC_RIGHT;
				break;
			case SDLK_ESCAPE:	// SELECT button
				key_scan = SC_ESCAPE;
				break;
			case SDLK_RETURN:	// START button
				key_scan = SC_ENTER;
				break;
			case SDLK_LCTRL:	// A button
			case SDLK_LALT:		// B button
			case SDLK_LSHIFT:	// Y button
			case SDLK_SPACE:	// X button
				key_scan = SC_SPACE;
				break;
			case SDLK_TAB: // LEFT SHOULDER
				key_scan = SC_TAB;
				break;
			case SDLK_BACKSPACE: // RIGHT SHOULDER
				key_scan = SC_BACKSPACE;
				break;
			default:;
				break;
			}
			if (key_scan != -1) Keys[key_scan] = key_value;
		}
	}

	// turn on/off fullscreen upscaling
#if defined(__DINGUX__)
	if (Keys[SC_TAB] == 1)
	{
		if (++StretchFullScreen > 2)	StretchFullScreen = 0;
		Keys[SC_TAB] = 0;
		memset(screen->pixels, 0, VModes[VMode].x * VModes[VMode].y * 2);
	}
#endif

	return 0;
}

int LM_GFX_Init()
{
	// Ignore pressing X for exit to OS
	SDL_putenv("DINGOO_IGNORE_OS_EVENTS=1");

	// Start SDL, other parameters will not do
	if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_TIMER | SDL_INIT_AUDIO) < 0) return 0;
	atexit(SDL_Quit);

	// Probe video modes sequentially - first 480x272, then 400x240 and then 320x240
	// All because dingux can be run on different handhelds (A320, A380, RZX-50)
#if defined(__DINGUX__)
	for (VMode = NUMOFVIDEOMODES - 1; VMode >= 0; VMode--)
	{
		if (SDL_VideoModeOK(VModes[VMode].x, VModes[VMode].y, 16, SDL_SWSURFACE) != 0)
		{
			screen = SDL_SetVideoMode(VModes[VMode].x, VModes[VMode].y, 16, SDL_SWSURFACE);
			break;
		}
	}

#elif defined(__DINGOO__)
// Set up screen, strictly 320 x 240 x 16 software surface
	screen = SDL_SetVideoMode(320, 240, 16, SDL_SWSURFACE);
#elif defined(_WIN32)
	screen = SDL_SetVideoMode(320, 240, 16, SDL_SWSURFACE);
#else
#error Platform not supported!
#endif

// create 320x200x8 surface
	small_screen = SDL_CreateRGBSurface(SDL_SWSURFACE, 320, 200, 8, 0, 0, 0, 0);
	SDL_SetPalette(small_screen, SDL_LOGPAL, (SDL_Color *)pal256, 0, 256);

	// Hide the cursor
	SDL_ShowCursor(SDL_DISABLE);

	return 1;
}

void LM_GFX_Deinit()
{
	//SDL_Quit();
}

/*
	The idea taken from http://tech-algorithm.com/articles/bilinear-image-scaling/

	Adapted it from java to c and from float to int

	args: source pixels 320x200x8, dest pixels 480x272x16 (400x240x16), source w & h, dest w & h
*/
void upscale_bilinear(unsigned char *pixels, unsigned short *temp, int w, int h, int w2, int h2)
{
	int x, y, index;
	int x_ratio = ((w - 1) * 256) / w2; // 664
	int y_ratio = ((h - 1) * 256) / h2; // 731

	int offset = 0;

	for (int i = 0; i < h2; i++)
		for (int j = 0; j < w2; j++)
		{
			int a, b, c, d;
			int blue, red, green;
			int x_diff, y_diff;

			x = (x_ratio * j) / 256; // 21
			y = (y_ratio * i) / 256; // 24
			x_diff = (x_ratio * j) & 255; // 912
			y_diff = (y_ratio * i) & 255; // 123
			index = (y*w + x);

			a = *(int *)&pal256[pixels[index] * 4]; // 255
			b = *(int *)&pal256[pixels[index + 1] * 4]; // 50
			c = *(int *)&pal256[pixels[index + w] * 4]; // 30
			d = *(int *)&pal256[pixels[index + w + 1] * 4]; // 10

#define R(z) (((z >> 0) & 0xff))
#define G(z) (((z >> 8) & 0xff))
#define B(z) (((z >> 16) & 0xff))

// blue element
// Yb = Ab(1-w)(1-h) + Bb(w)(1-h) + Cb(h)(1-w) + Db(wh)
			blue = B(a) * (256 - x_diff) * (256 - y_diff) + B(b) * (x_diff) * (256 - y_diff) +
				B(c) * (y_diff) 	   * (256 - x_diff) + B(d) * (x_diff  * y_diff);
			// 255 * 88 * 877 + 50 * 912 * 877 + 30 * 123 * 88 + 10 * 112299

			// 19679880 + 39991200 + 324720 + 1122990

			// green element
			// Yg = Ag(1-w)(1-h) + Bg(w)(1-h) + Cg(h)(1-w) + Dg(wh)
			green = G(a) * (256 - x_diff) * (256 - y_diff) + G(b) * (x_diff) * (256 - y_diff) +
				G(c) * (y_diff)	 * (256 - x_diff) + G(d) * (x_diff  * y_diff);

			// red element
			// Yr = Ar(1-w)(1-h) + Br(w)(1-h) + Cr(h)(1-w) + Dr(wh)
			red = R(a) * (256 - x_diff) * (256 - y_diff) + R(b) * (x_diff) * (256 - y_diff) +
				R(c) * (y_diff)	 * (256 - x_diff) + R(d) * (x_diff  * y_diff);

#undef R
#undef G
#undef B

			red >>= 16;
			green >>= 16;
			blue >>= 16;


			temp[offset++] =
				((red << 8) & (0x1f << 11)) |
				((green << 3) & (0x3f << 5)) |
				((blue >> 3) & (0x1f << 0));
		}


}
/*
	The idea taken from http://www.compuphase.com/graphic/scale.htm

	args: source pixels 320x200x8, dest pixels 480x272x16 (400x240x16), source w & h, dest w & h
*/
void upscale_bresenham(unsigned char *pixels, unsigned short *temp, int w, int h, int w2, int h2)
{
	int midw = w2 >> 1;
	int midh = h2 >> 1;
	int Ew = 0;
	int Eh = 0;
	int source = 0, target = 0;
	int dh = 0;

	for (int i = 0; i < h2; i++)
	{
		Ew = 0;
		source = dh * w;

		for (int j = 0; j < w2; j++)
		{
			int r, g, b;

			r = pal256[pixels[source] * 4];
			g = pal256[pixels[source] * 4 + 1];
			b = pal256[pixels[source] * 4 + 2];

#define AVERAGE(z, x) (((z) + (x)) >> 1)
			if (Ew >= midw) { // average + 1
				r = AVERAGE(r, pal256[pixels[source + 1] * 4]);
				g = AVERAGE(g, pal256[pixels[source + 1] * 4 + 1]);
				b = AVERAGE(b, pal256[pixels[source + 1] * 4 + 2]);
			}
			if (Eh >= midh) { // average + w
				r = AVERAGE(r, pal256[pixels[source + w] * 4]);
				g = AVERAGE(g, pal256[pixels[source + w] * 4 + 1]);
				b = AVERAGE(b, pal256[pixels[source + w] * 4 + 2]);
			}
#undef AVERAGE
			temp[target++] =
				((r << 8) & (0x1f << 11)) |
				((g << 3) & (0x3f << 5)) |
				((b >> 3) & (0x1f << 0));

			Ew += w; if (Ew >= w2) { Ew -= w2; source += 1; }

		}
		Eh += h; if (Eh >= h2) { Eh -= h2; dh++; }
	}
}

void LM_GFX_Flip(unsigned char *p)
{

	// convert from 320x200x8 to 320x240x16

	// if any Dingux incarnation
#if defined(__DINGUX__)

// bilinear or bresenham scaling
	if (StretchFullScreen == 2)
	{
		if (SDL_MUSTLOCK(screen)) SDL_LockSurface(screen);
		upscale_bilinear(p, (unsigned short *)screen->pixels, 320, 200, VModes[VMode].x, VModes[VMode].y);
		if (SDL_MUSTLOCK(screen)) SDL_UnlockSurface(screen);
	}
	else
		if (StretchFullScreen == 1)
		{
			if (SDL_MUSTLOCK(screen)) SDL_LockSurface(screen);
			upscale_bresenham(p, (unsigned short *)screen->pixels, 320, 200, VModes[VMode].x, VModes[VMode].y);
			if (SDL_MUSTLOCK(screen)) SDL_UnlockSurface(screen);
		}
		else
		{
			SDL_Rect dstrect;

			// center windows
			dstrect.x = (VModes[VMode].x - 320) / 2;
			dstrect.y = (VModes[VMode].y - 200) / 2;

			SDL_BlitSurface(small_screen, 0, screen, &dstrect);
		}

	// if Dingoo OS Native
#elif defined(__DINGOO__)
	{
		SDL_Rect dstrect;

		dstrect.x = 0;
		dstrect.y = 20;

		SDL_BlitSurface(small_screen, 0, screen, &dstrect);
	}

#elif defined(_WIN32)
	SDL_Rect dstrect;

	dstrect.x = 0;
	dstrect.y = 20;

	SDL_BlitSurface(small_screen, 0, screen, &dstrect);
#else
#error Platform not supported!
#endif

// Update Screen
	SDL_Flip(screen);
}

void LM_GFX_WaitVSync()
{
	// do nothing
}

void LM_GFX_SetScale(int param)
{
	// do nothing
}

// palette in hardware rgba mode
unsigned char pal256[1024] = {
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAA, 0x00, 0x00, 0xAA, 0x00, 0x00, 0x00, 0xAA, 0xAA, 0x00,
	 0xAA, 0x00, 0x00, 0x00, 0xAA, 0x00, 0xAA, 0x00, 0xAA, 0x55, 0x00, 0x00, 0xAA, 0xAA, 0xAA, 0x00,
	 0x55, 0x55, 0x55, 0x00, 0x55, 0x55, 0xFF, 0x00, 0x55, 0xFF, 0x55, 0x00, 0x55, 0xFF, 0xFF, 0x00,
	 0xFF, 0x55, 0x55, 0x00, 0xFF, 0x55, 0xFF, 0x00, 0xFF, 0xFF, 0x55, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x14, 0x14, 0x14, 0x00, 0x20, 0x20, 0x20, 0x00, 0x2C, 0x2C, 0x2C, 0x00,
	 0x38, 0x38, 0x38, 0x00, 0x44, 0x44, 0x44, 0x00, 0x50, 0x50, 0x50, 0x00, 0x61, 0x61, 0x61, 0x00,
	 0x71, 0x71, 0x71, 0x00, 0x81, 0x81, 0x81, 0x00, 0x91, 0x91, 0x91, 0x00, 0xA1, 0xA1, 0xA1, 0x00,
	 0xB6, 0xB6, 0xB6, 0x00, 0xCA, 0xCA, 0xCA, 0x00, 0xE2, 0xE2, 0xE2, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	 0x00, 0x00, 0xFF, 0x00, 0x40, 0x00, 0xFF, 0x00, 0x7D, 0x00, 0xFF, 0x00, 0xBE, 0x00, 0xFF, 0x00,
	 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xBE, 0x00, 0xFF, 0x00, 0x7D, 0x00, 0xFF, 0x00, 0x40, 0x00,
	 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x40, 0x00, 0x00, 0xFF, 0x7D, 0x00, 0x00, 0xFF, 0xBE, 0x00, 0x00,
	 0xFF, 0xFF, 0x00, 0x00, 0xBE, 0xFF, 0x00, 0x00, 0x7D, 0xFF, 0x00, 0x00, 0x40, 0xFF, 0x00, 0x00,
	 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x40, 0x00, 0x00, 0xFF, 0x7D, 0x00, 0x00, 0xFF, 0xBE, 0x00,
	 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xBE, 0xFF, 0x00, 0x00, 0x7D, 0xFF, 0x00, 0x00, 0x40, 0xFF, 0x00,
	 0x7D, 0x7D, 0xFF, 0x00, 0x9D, 0x7D, 0xFF, 0x00, 0xBE, 0x7D, 0xFF, 0x00, 0xDE, 0x7D, 0xFF, 0x00,
	 0xFF, 0x7D, 0xFF, 0x00, 0xFF, 0x7D, 0xDE, 0x00, 0xFF, 0x7D, 0xBE, 0x00, 0xFF, 0x7D, 0x9D, 0x00,
	 0xFF, 0x7D, 0x7D, 0x00, 0xFF, 0x9D, 0x7D, 0x00, 0xFF, 0xBE, 0x7D, 0x00, 0xFF, 0xDE, 0x7D, 0x00,
	 0xFF, 0xFF, 0x7D, 0x00, 0xDE, 0xFF, 0x7D, 0x00, 0xBE, 0xFF, 0x7D, 0x00, 0x9D, 0xFF, 0x7D, 0x00,
	 0x7D, 0xFF, 0x7D, 0x00, 0x7D, 0xFF, 0x9D, 0x00, 0x7D, 0xFF, 0xBE, 0x00, 0x7D, 0xFF, 0xDE, 0x00,
	 0x7D, 0xFF, 0xFF, 0x00, 0x7D, 0xDE, 0xFF, 0x00, 0x7D, 0xBE, 0xFF, 0x00, 0x7D, 0x9D, 0xFF, 0x00,
	 0xB6, 0xB6, 0xFF, 0x00, 0xC6, 0xB6, 0xFF, 0x00, 0xDA, 0xB6, 0xFF, 0x00, 0xEA, 0xB6, 0xFF, 0x00,
	 0xFF, 0xB6, 0xFF, 0x00, 0xFF, 0xB6, 0xEA, 0x00, 0xFF, 0xB6, 0xDA, 0x00, 0xFF, 0xB6, 0xC6, 0x00,
	 0xFF, 0xB6, 0xB6, 0x00, 0xFF, 0xC6, 0xB6, 0x00, 0xFF, 0xDA, 0xB6, 0x00, 0xFF, 0xEA, 0xB6, 0x00,
	 0xFF, 0xFF, 0xB6, 0x00, 0xEA, 0xFF, 0xB6, 0x00, 0xDA, 0xFF, 0xB6, 0x00, 0xC6, 0xFF, 0xB6, 0x00,
	 0xB6, 0xFF, 0xB6, 0x00, 0xB6, 0xFF, 0xC6, 0x00, 0xB6, 0xFF, 0xDA, 0x00, 0xB6, 0xFF, 0xEA, 0x00,
	 0xB6, 0xFF, 0xFF, 0x00, 0xB6, 0xEA, 0xFF, 0x00, 0xB6, 0xDA, 0xFF, 0x00, 0xB6, 0xC6, 0xFF, 0x00,
	 0x00, 0x00, 0x71, 0x00, 0x1C, 0x00, 0x71, 0x00, 0x38, 0x00, 0x71, 0x00, 0x55, 0x00, 0x71, 0x00,
	 0x71, 0x00, 0x71, 0x00, 0x71, 0x00, 0x55, 0x00, 0x71, 0x00, 0x38, 0x00, 0x71, 0x00, 0x1C, 0x00,
	 0x71, 0x00, 0x00, 0x00, 0x71, 0x1C, 0x00, 0x00, 0x71, 0x38, 0x00, 0x00, 0x71, 0x55, 0x00, 0x00,
	 0x71, 0x71, 0x00, 0x00, 0x55, 0x71, 0x00, 0x00, 0x38, 0x71, 0x00, 0x00, 0x1C, 0x71, 0x00, 0x00,
	 0x00, 0x71, 0x00, 0x00, 0x00, 0x71, 0x1C, 0x00, 0x00, 0x71, 0x38, 0x00, 0x00, 0x71, 0x55, 0x00,
	 0x00, 0x71, 0x71, 0x00, 0x00, 0x55, 0x71, 0x00, 0x00, 0x38, 0x71, 0x00, 0x00, 0x1C, 0x71, 0x00,
	 0x38, 0x38, 0x71, 0x00, 0x44, 0x38, 0x71, 0x00, 0x55, 0x38, 0x71, 0x00, 0x61, 0x38, 0x71, 0x00,
	 0x71, 0x38, 0x71, 0x00, 0x71, 0x38, 0x61, 0x00, 0x71, 0x38, 0x55, 0x00, 0x71, 0x38, 0x44, 0x00,
	 0x71, 0x38, 0x38, 0x00, 0x71, 0x44, 0x38, 0x00, 0x71, 0x55, 0x38, 0x00, 0x71, 0x61, 0x38, 0x00,
	 0x71, 0x71, 0x38, 0x00, 0x61, 0x71, 0x38, 0x00, 0x55, 0x71, 0x38, 0x00, 0x44, 0x71, 0x38, 0x00,
	 0x38, 0x71, 0x38, 0x00, 0x38, 0x71, 0x44, 0x00, 0x38, 0x71, 0x55, 0x00, 0x38, 0x71, 0x61, 0x00,
	 0x38, 0x71, 0x71, 0x00, 0x38, 0x61, 0x71, 0x00, 0x38, 0x55, 0x71, 0x00, 0x38, 0x44, 0x71, 0x00,
	 0x50, 0x50, 0x71, 0x00, 0x59, 0x50, 0x71, 0x00, 0x61, 0x50, 0x71, 0x00, 0x69, 0x50, 0x71, 0x00,
	 0x71, 0x50, 0x71, 0x00, 0x71, 0x50, 0x69, 0x00, 0x71, 0x50, 0x61, 0x00, 0x71, 0x50, 0x59, 0x00,
	 0x71, 0x50, 0x50, 0x00, 0x71, 0x59, 0x50, 0x00, 0x71, 0x61, 0x50, 0x00, 0x71, 0x69, 0x50, 0x00,
	 0x71, 0x71, 0x50, 0x00, 0x69, 0x71, 0x50, 0x00, 0x61, 0x71, 0x50, 0x00, 0x59, 0x71, 0x50, 0x00,
	 0x50, 0x71, 0x50, 0x00, 0x50, 0x71, 0x59, 0x00, 0x50, 0x71, 0x61, 0x00, 0x50, 0x71, 0x69, 0x00,
	 0x50, 0x71, 0x71, 0x00, 0x50, 0x69, 0x71, 0x00, 0x50, 0x61, 0x71, 0x00, 0x50, 0x59, 0x71, 0x00,
	 0x00, 0x00, 0x40, 0x00, 0x10, 0x00, 0x40, 0x00, 0x20, 0x00, 0x40, 0x00, 0x30, 0x00, 0x40, 0x00,
	 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x30, 0x00, 0x40, 0x00, 0x20, 0x00, 0x40, 0x00, 0x10, 0x00,
	 0x40, 0x00, 0x00, 0x00, 0x40, 0x10, 0x00, 0x00, 0x40, 0x20, 0x00, 0x00, 0x40, 0x30, 0x00, 0x00,
	 0x40, 0x40, 0x00, 0x00, 0x30, 0x40, 0x00, 0x00, 0x20, 0x40, 0x00, 0x00, 0x10, 0x40, 0x00, 0x00,
	 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x10, 0x00, 0x00, 0x40, 0x20, 0x00, 0x00, 0x40, 0x30, 0x00,
	 0x00, 0x40, 0x40, 0x00, 0x00, 0x30, 0x40, 0x00, 0x00, 0x20, 0x40, 0x00, 0x00, 0x10, 0x40, 0x00,
	 0x20, 0x20, 0x40, 0x00, 0x28, 0x20, 0x40, 0x00, 0x30, 0x20, 0x40, 0x00, 0x38, 0x20, 0x40, 0x00,
	 0x40, 0x20, 0x40, 0x00, 0x40, 0x20, 0x38, 0x00, 0x40, 0x20, 0x30, 0x00, 0x40, 0x20, 0x28, 0x00,
	 0x40, 0x20, 0x20, 0x00, 0x40, 0x28, 0x20, 0x00, 0x40, 0x30, 0x20, 0x00, 0x40, 0x38, 0x20, 0x00,
	 0x40, 0x40, 0x20, 0x00, 0x38, 0x40, 0x20, 0x00, 0x30, 0x40, 0x20, 0x00, 0x28, 0x40, 0x20, 0x00,
	 0x20, 0x40, 0x20, 0x00, 0x20, 0x40, 0x28, 0x00, 0x20, 0x40, 0x30, 0x00, 0x20, 0x40, 0x38, 0x00,
	 0x20, 0x40, 0x40, 0x00, 0x20, 0x38, 0x40, 0x00, 0x20, 0x30, 0x40, 0x00, 0x20, 0x28, 0x40, 0x00,
	 0x2C, 0x2C, 0x40, 0x00, 0x30, 0x2C, 0x40, 0x00, 0x34, 0x2C, 0x40, 0x00, 0x3C, 0x2C, 0x40, 0x00,
	 0x40, 0x2C, 0x40, 0x00, 0x40, 0x2C, 0x3C, 0x00, 0x40, 0x2C, 0x34, 0x00, 0x40, 0x2C, 0x30, 0x00,
	 0x40, 0x2C, 0x2C, 0x00, 0x40, 0x30, 0x2C, 0x00, 0x40, 0x34, 0x2C, 0x00, 0x40, 0x3C, 0x2C, 0x00,
	 0x40, 0x40, 0x2C, 0x00, 0x3C, 0x40, 0x2C, 0x00, 0x34, 0x40, 0x2C, 0x00, 0x30, 0x40, 0x2C, 0x00,
	 0x2C, 0x40, 0x2C, 0x00, 0x2C, 0x40, 0x30, 0x00, 0x2C, 0x40, 0x34, 0x00, 0x2C, 0x40, 0x3C, 0x00,
	 0x2C, 0x40, 0x40, 0x00, 0x2C, 0x3C, 0x40, 0x00, 0x2C, 0x34, 0x40, 0x00, 0x2C, 0x30, 0x40, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
